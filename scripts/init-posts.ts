#!/usr/bin/env tsx

import { config } from 'dotenv';
import { createClient } from '@supabase/supabase-js';
import { join } from 'path';
import * as readline from 'readline';

// Âä†ËΩΩÁéØÂ¢ÉÂèòÈáè
config({ path: join(process.cwd(), '.env.local') });

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

function question(query: string): Promise<string> {
  return new Promise(resolve => rl.question(query, resolve));
}

const initialPosts = [
  {
    title: "Getting Started with Next.js 15 and Server Components",
    excerpt: "Learn how to build modern web applications with Next.js 15 and its revolutionary Server Components feature. This comprehensive guide covers everything from setup to deployment.",
    content: `# Getting Started with Next.js 15 and Server Components

Next.js 15 introduces powerful new features that revolutionize how we build React applications. **Server Components** represent a paradigm shift in how we think about rendering and data fetching.

## What are Server Components?

Server Components run on the server and can directly access backend resources like databases, file systems, and APIs without additional API layers.

### Key Benefits

- **Zero Bundle Size**: Server Components don't add to your JavaScript bundle
- **Direct Backend Access**: No need for API routes for simple data fetching  
- **Better Performance**: Reduced hydration and faster loading times
- **Improved SEO**: Better server-side rendering capabilities

## Getting Started

First, create a new Next.js 15 project:

\`\`\`bash
npx create-next-app@latest my-app --app
cd my-app
npm run dev
\`\`\`

## Example Server Component

Here's a simple example of a Server Component that fetches data:

\`\`\`tsx
async function PostList() {
  // This runs on the server
  const posts = await fetch('https://api.example.com/posts');
  const data = await posts.json();
  
  return (
    <div className="grid gap-4">
      {data.map(post => (
        <Article key={post.id} post={post} />
      ))}
    </div>
  );
}
\`\`\`

## Client vs Server Components

> **Important**: Use Server Components by default, and only add 'use client' when you need interactivity.

- **Server Components**: Data fetching, static content
- **Client Components**: Interactive features, event handlers, state

## Best Practices

1. **Start with Server Components** - They're faster and more efficient
2. **Use Client Components sparingly** - Only when you need interactivity
3. **Compose them together** - Server Components can render Client Components
4. **Fetch data close to where it's used** - Reduces waterfall requests

---

This is just the beginning of what's possible with Next.js 15! The new architecture opens up exciting possibilities for building faster, more efficient web applications.`,
    cover_image: "https://picsum.photos/600/338?random=1",
    slug: "getting-started-with-nextjs-15",
    published_at: "2024-03-15T10:00:00Z",
    status: "published" as const,
    tags: ["Next.js", "React", "Server Components", "JavaScript"]
  },
  {
    title: "Building a Blog with Supabase and Next.js",
    excerpt: "Discover how to create a full-featured blog using Supabase as the backend and Next.js for the frontend. Complete with authentication, real-time features, and more.",
    content: `# Building a Blog with Supabase and Next.js

In this comprehensive tutorial, we'll build a complete blog application using **Supabase** as our backend and **Next.js** for the frontend.

## Why Supabase?

Supabase provides everything you need for a modern application:

- üóÑÔ∏è **PostgreSQL database** - Powerful relational database
- ‚ö° **Real-time subscriptions** - Live updates without polling
- üîê **Built-in authentication** - User management out of the box
- üöÄ **Auto-generated APIs** - REST and GraphQL APIs
- üìÅ **File storage** - Handle images and documents

## Project Setup

Let's start by setting up our Next.js project:

\`\`\`bash
npx create-next-app@latest blog-app --typescript --tailwind
cd blog-app
npm install @supabase/supabase-js
\`\`\`

## Database Schema

Our blog needs a robust posts table. Here's the SQL schema:

\`\`\`sql
CREATE TABLE posts (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  title TEXT NOT NULL,
  excerpt TEXT NOT NULL,
  content TEXT NOT NULL,
  cover_image TEXT,
  slug TEXT UNIQUE NOT NULL,
  views INTEGER DEFAULT 0,
  likes INTEGER DEFAULT 0,
  published_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  author_id UUID,
  tags TEXT[],
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived'))
);
\`\`\`

## Supabase Client Setup

Create a Supabase client in \`lib/supabase.ts\`:

\`\`\`typescript
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

export const supabase = createClient(supabaseUrl, supabaseKey)
\`\`\`

## Real-time Features

One of Supabase's killer features is real-time updates. Here's how to listen for changes:

\`\`\`typescript
useEffect(() => {
  const channel = supabase
    .channel('posts')
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'posts' },
      (payload) => {
        console.log('Change received!', payload)
        // Update your UI here
      }
    )
    .subscribe()

  return () => supabase.removeChannel(channel)
}, [])
\`\`\`

## Data Fetching

Create a service layer for your posts:

\`\`\`typescript
export async function getPosts() {
  const { data, error } = await supabase
    .from('posts')
    .select('*')
    .eq('status', 'published')
    .order('published_at', { ascending: false })

  if (error) throw error
  return data
}
\`\`\`

## Row Level Security

Don't forget to enable RLS for security:

\`\`\`sql
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;

-- Allow public read access to published posts
CREATE POLICY "Public posts are viewable by everyone" 
ON posts FOR SELECT 
USING (status = 'published');
\`\`\`

---

With this setup, you have a production-ready blog that can scale to millions of users! üöÄ`,
    cover_image: "https://picsum.photos/600/338?random=2",
    slug: "building-blog-with-supabase",
    published_at: "2024-03-14T09:30:00Z",
    status: "published" as const,
    tags: ["Supabase", "Next.js", "PostgreSQL", "Real-time"]
  },
  {
    title: "Implementing Dark Mode with Next-Themes",
    excerpt: "A comprehensive guide to adding dark mode support to your Next.js application using next-themes. Learn about system preferences, persistence, and smooth transitions.",
    content: `# Implementing Dark Mode with Next-Themes

Dark mode has become an **essential feature** for modern web applications. In this guide, we'll implement dark mode using \`next-themes\`, the most popular solution for Next.js applications.

## Why Next-Themes?

\`next-themes\` offers several advantages over custom implementations:

| Feature | next-themes | Custom |
|---------|-------------|--------|
| System preference detection | ‚úÖ | ‚ùå |
| No flash of incorrect theme | ‚úÖ | ‚ùå |
| Persistence across sessions | ‚úÖ | ‚ö†Ô∏è |
| Multiple theme support | ‚úÖ | ‚ùå |
| TypeScript support | ‚úÖ | ‚ö†Ô∏è |

## Installation

Start by installing the required package:

\`\`\`bash
npm install next-themes
\`\`\`

## Basic Setup

Wrap your app with the \`ThemeProvider\` in your root layout:

\`\`\`tsx
// app/layout.tsx
import { ThemeProvider } from 'next-themes'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body>
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          {children}
        </ThemeProvider>
      </body>
    </html>
  )
}
\`\`\`

## Theme Toggle Component

Create a beautiful toggle component:

\`\`\`tsx
'use client'

import { useTheme } from 'next-themes'
import { Button } from '@/components/ui/button'
import { Moon, Sun } from 'lucide-react'

export function ThemeToggle() {
  const { theme, setTheme } = useTheme()

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
    >
      <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}
\`\`\`

## CSS Configuration

Configure your CSS variables for seamless theme switching:

\`\`\`css
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    /* ... other light theme variables */
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    /* ... other dark theme variables */
  }
}
\`\`\`

## Advanced Configuration

For more complex scenarios, you can configure additional options:

\`\`\`tsx
<ThemeProvider
  attribute="class"
  defaultTheme="system"
  enableSystem
  themes={['light', 'dark', 'blue', 'green']}
  storageKey="app-theme"
>
  {children}
</ThemeProvider>
\`\`\`

## Preventing Flash

To prevent the flash of incorrect theme, add this to your HTML:

\`\`\`tsx
<html lang="en" suppressHydrationWarning>
\`\`\`

> **Note**: The \`suppressHydrationWarning\` prop prevents React from warning about the theme mismatch during hydration.

## Best Practices

1. **Use CSS variables** - They provide the smoothest transitions
2. **Test both themes** - Ensure all components work in both modes
3. **Consider accessibility** - Some users prefer high contrast themes
4. **Respect system preferences** - Default to system theme when possible

---

With this implementation, your users will enjoy a seamless dark mode experience that respects their preferences and provides smooth transitions! üåô`,
    cover_image: "https://picsum.photos/600/338?random=3",
    slug: "dark-mode-with-next-themes",
    published_at: "2024-03-13T14:15:00Z",
    status: "published" as const,
    tags: ["Dark Mode", "Next.js", "CSS", "UX"]
  }
];

const initialTags = [
  { name: "Next.js", slug: "nextjs", description: "ReactÊ°ÜÊû∂ÔºåÁî®‰∫éÊûÑÂª∫Áé∞‰ª£WebÂ∫îÁî®Á®ãÂ∫è" },
  { name: "React", slug: "react", description: "Áî®‰∫éÊûÑÂª∫Áî®Êà∑ÁïåÈù¢ÁöÑJavaScriptÂ∫ì" },
  { name: "TypeScript", slug: "typescript", description: "JavaScriptÁöÑË∂ÖÈõÜÔºåÊ∑ªÂä†‰∫ÜÁ±ªÂûãÂÆâÂÖ®" },
  { name: "JavaScript", slug: "javascript", description: "Âä®ÊÄÅÁºñÁ®ãËØ≠Ë®ÄÔºåWebÂºÄÂèëÁöÑÂü∫Á°Ä" },
  { name: "CSS", slug: "css", description: "Áî®‰∫éÊ†∑ÂºèÂåñWebÈ°µÈù¢ÁöÑÊ†∑ÂºèË°®ËØ≠Ë®Ä" },
  { name: "Tailwind CSS", slug: "tailwind-css", description: "ÂÆûÁî®‰ºòÂÖàÁöÑCSSÊ°ÜÊû∂" },
  { name: "Supabase", slug: "supabase", description: "ÂºÄÊ∫êÁöÑFirebaseÊõø‰ª£ÂìÅ" },
  { name: "PostgreSQL", slug: "postgresql", description: "Âº∫Â§ßÁöÑÂºÄÊ∫êÂÖ≥Á≥ªÂûãÊï∞ÊçÆÂ∫ì" },
  { name: "Server Components", slug: "server-components", description: "ReactÊúçÂä°Âô®ÁªÑ‰ª∂ÊäÄÊúØ" },
  { name: "Real-time", slug: "real-time", description: "ÂÆûÊó∂Êï∞ÊçÆÂêåÊ≠•ÊäÄÊúØ" },
  { name: "Dark Mode", slug: "dark-mode", description: "ÊöóËâ≤‰∏ªÈ¢òÊ®°Âºè" },
  { name: "UX", slug: "ux", description: "Áî®Êà∑‰ΩìÈ™åËÆæËÆ°" },
  { name: "Performance", slug: "performance", description: "ÊÄßËÉΩ‰ºòÂåñÁõ∏ÂÖ≥ÊäÄÊúØ" },
  { name: "SEO", slug: "seo", description: "ÊêúÁ¥¢ÂºïÊìé‰ºòÂåñ" },
  { name: "Frontend", slug: "frontend", description: "ÂâçÁ´ØÂºÄÂèëÊäÄÊúØ" },
  { name: "Backend", slug: "backend", description: "ÂêéÁ´ØÂºÄÂèëÊäÄÊúØ" },
  { name: "Database", slug: "database", description: "Êï∞ÊçÆÂ∫ìÁõ∏ÂÖ≥ÊäÄÊúØ" },
  { name: "Authentication", slug: "authentication", description: "Áî®Êà∑ËÆ§ËØÅÂíåÊéàÊùÉ" },
  { name: "API", slug: "api", description: "Â∫îÁî®Á®ãÂ∫èÊé•Âè£" },
  { name: "Tutorial", slug: "tutorial", description: "ÊïôÁ®ãÂíåÊåáÂçó" }
];

async function ensureTableExists(supabase: any, tableName: string, createSql?: string) {
  console.log(`üîß Á°Æ‰øù ${tableName} Ë°®Â≠òÂú®...`);
  
  try {
    const { data, error } = await supabase
      .from(tableName)
      .select('*')
      .limit(1);
    
    if (!error) {
      console.log(`‚úÖ ${tableName} Ë°®Â∑≤Â≠òÂú®`);
      return true;
    } else if (error.code === 'PGRST116' || error.message.includes('does not exist')) {
      console.log(`‚ùå ${tableName} Ë°®‰∏çÂ≠òÂú®`);
      return false;
    } else {
      console.log(`‚ö†Ô∏è  ${tableName} Ë°®ÂèØËÉΩÊúâÈóÆÈ¢ò:`, error.message);
      return true;
    }
  } catch (error: any) {
    console.log(`‚ùå Ê£ÄÊü• ${tableName} Ë°®Êó∂ÂèëÁîüÈîôËØØ:`, error.message);
    return false;
  }
}

async function createAdmin(supabase: any) {
  console.log('\nüë§ ÂàõÂª∫ÁÆ°ÁêÜÂëòË¥¶Êà∑');
  console.log('ËØ∑ËæìÂÖ•ÁÆ°ÁêÜÂëò‰ø°ÊÅØÔºàÁî®‰∫éÁôªÂΩïÂêéÂè∞ÁÆ°ÁêÜÔºâ\n');
  
  const email = await question('ËØ∑ËæìÂÖ•ÁÆ°ÁêÜÂëòÈÇÆÁÆ±: ');
  const password = await question('ËØ∑ËæìÂÖ•ÁÆ°ÁêÜÂëòÂØÜÁ†Å (Ëá≥Â∞ë6‰Ωç): ');

  if (password.length < 6) {
    throw new Error('ÂØÜÁ†ÅÈïøÂ∫¶Ëá≥Â∞ëÈúÄË¶Å6‰Ωç');
  }

  console.log('\nÂàõÂª∫ÁÆ°ÁêÜÂëòË¥¶Êà∑‰∏≠...');

  // ÂàõÂª∫Áî®Êà∑
  const { data: authData, error: authError } = await supabase.auth.admin.createUser({
    email,
    password,
    email_confirm: true // Ëá™Âä®Á°ÆËÆ§ÈÇÆÁÆ±
  });

  if (authError) {
    throw authError;
  }

  console.log('‚úÖ ÁÆ°ÁêÜÂëòË¥¶Êà∑ÂàõÂª∫ÊàêÂäü!');
  console.log(`üìß ÈÇÆÁÆ±: ${email}`);
  console.log(`üÜî Áî®Êà∑ID: ${authData.user.id}`);
  
  return authData.user.id;
}

async function initializeTags(supabase: any) {
  console.log('\nüè∑Ô∏è  ÂàùÂßãÂåñÊ†áÁ≠æÊï∞ÊçÆ...');
  
  // Ê∏ÖÁêÜÁé∞ÊúâÊ†áÁ≠æÊï∞ÊçÆ
  const { error: deleteTagsError } = await supabase
    .from('tags')
    .delete()
    .neq('id', '00000000-0000-0000-0000-000000000000');
  
  if (deleteTagsError) {
    console.log('‚ö†Ô∏è  Ê∏ÖÁêÜÊ†áÁ≠æÊï∞ÊçÆÊó∂ÂèëÁîüÈîôËØØ:', deleteTagsError.message);
  } else {
    console.log('‚úÖ Áé∞ÊúâÊ†áÁ≠æÊï∞ÊçÆÂ∑≤Ê∏ÖÁêÜ');
  }
  
  // ÊèíÂÖ•ÂàùÂßãÊ†áÁ≠æ
  const { data: tagsData, error: tagsError } = await supabase
    .from('tags')
    .insert(initialTags)
    .select();
  
  if (tagsError) {
    console.error('‚ùå ÊèíÂÖ•Ê†áÁ≠æÂ§±Ë¥•:', tagsError);
    throw tagsError;
  }
  
  console.log(`‚úÖ Â∑≤ÊèíÂÖ• ${tagsData?.length} ‰∏™Ê†áÁ≠æ`);
  return tagsData;
}

async function initializePosts(supabase: any, authorId: string, tagsData: any[]) {
  console.log('\nüìù ÂàùÂßãÂåñÊñáÁ´†Êï∞ÊçÆ...');
  
  // Ê∏ÖÁêÜÁé∞ÊúâÊñáÁ´†Êï∞ÊçÆ
  const { error: deleteError } = await supabase
    .from('posts')
    .delete()
    .neq('id', '00000000-0000-0000-0000-000000000000');
  
  if (deleteError) {
    console.log('‚ö†Ô∏è  Ê∏ÖÁêÜÊñáÁ´†Êï∞ÊçÆÊó∂ÂèëÁîüÈîôËØØ:', deleteError.message);
  } else {
    console.log('‚úÖ Áé∞ÊúâÊñáÁ´†Êï∞ÊçÆÂ∑≤Ê∏ÖÁêÜ');
  }
  
  // ‰∏∫ÊñáÁ´†Ê∑ªÂä† author_id
  const postsWithAuthor = initialPosts.map(post => ({
    ...post,
    author_id: authorId
  }));
  
  // ÊèíÂÖ•Á§∫‰æãÊñáÁ´†
  const { data: postsData, error } = await supabase
    .from('posts')
    .insert(postsWithAuthor)
    .select();
  
  if (error) {
    console.error('‚ùå ÊèíÂÖ•ÊñáÁ´†Â§±Ë¥•:', error);
    throw error;
  }
  
  console.log(`‚úÖ Â∑≤ÊèíÂÖ• ${postsData?.length} ÁØáÊñáÁ´†`);
  
  // ÂàõÂª∫ÊñáÁ´†-Ê†áÁ≠æÂÖ≥ËÅî
  console.log('üîó ÂàõÂª∫ÊñáÁ´†-Ê†áÁ≠æÂÖ≥ËÅî...');
  
  const postTagRelations = [];
  for (const post of postsData) {
    const originalPost = initialPosts.find(p => p.slug === post.slug);
    if (originalPost?.tags) {
      for (const tagName of originalPost.tags) {
        const tag = tagsData.find(t => t.name === tagName);
        if (tag) {
          postTagRelations.push({
            post_id: post.id,
            tag_id: tag.id
          });
        }
      }
    }
  }
  
  if (postTagRelations.length > 0) {
    const { error: relationError } = await supabase
      .from('post_tags')
      .insert(postTagRelations);
    
    if (relationError) {
      console.log('‚ö†Ô∏è  ÂàõÂª∫ÊñáÁ´†-Ê†áÁ≠æÂÖ≥ËÅîÊó∂ÂèëÁîüÈîôËØØ:', relationError.message);
    } else {
      console.log(`‚úÖ Â∑≤ÂàõÂª∫ ${postTagRelations.length} ‰∏™ÊñáÁ´†-Ê†áÁ≠æÂÖ≥ËÅî`);
    }
  }
  
  return postsData;
}

async function initializeDatabase() {
  console.log('üöÄ ÂºÄÂßãÊï∞ÊçÆÂ∫ìÂàùÂßãÂåñ...\n');
  
  try {
    // Ê£ÄÊü•ÁéØÂ¢ÉÂèòÈáè
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
    
    if (!supabaseUrl) {
      throw new Error('Áº∫Â∞ëÁéØÂ¢ÉÂèòÈáè NEXT_PUBLIC_SUPABASE_URL');
    }
    
    if (!serviceRoleKey) {
      throw new Error('Áº∫Â∞ëÁéØÂ¢ÉÂèòÈáè SUPABASE_SERVICE_ROLE_KEY');
    }
    
    console.log('‚úÖ ÁéØÂ¢ÉÂèòÈáèÊ£ÄÊü•ÈÄöËøá');
    console.log(`üì° ËøûÊé•Âà∞ Supabase: ${supabaseUrl.replace(/https?:\/\/([^.]+)\..*/, 'https://$1.supabase.co')}`);
    
    // ÂàõÂª∫ÁÆ°ÁêÜÂëòÂÆ¢Êà∑Á´Ø
    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    });
    
    // Ê£ÄÊü•ÂøÖË¶ÅÁöÑË°®ÊòØÂê¶Â≠òÂú®
    const postsTableExists = await ensureTableExists(supabase, 'posts');
    const tagsTableExists = await ensureTableExists(supabase, 'tags');
    const postTagsTableExists = await ensureTableExists(supabase, 'post_tags');
    
    if (!postsTableExists || !tagsTableExists || !postTagsTableExists) {
      console.log('\n‚ö†Ô∏è  ÂøÖË¶ÅÁöÑË°®‰∏çÂ≠òÂú®ÔºÅ');
      console.log('ËØ∑Âú® Supabase SQL ÁºñËæëÂô®‰∏≠ËøêË°å‰ª•‰∏ãËøÅÁßªÊñá‰ª∂Ôºö');
      console.log('1. supabase/migrations/001_create_posts_table.sql');
      console.log('2. supabase/migrations/002_add_functions.sql');
      console.log('3. TAGS_SETUP.md ‰∏≠ÁöÑ SQL ËØ≠Âè•');
      throw new Error('Êï∞ÊçÆÂ∫ìË°®Êú™ÂàõÂª∫ÔºåËØ∑ÂÖàÂàõÂª∫Ë°®ÁªìÊûÑ');
    }
    
    // ÂàõÂª∫ÁÆ°ÁêÜÂëòË¥¶Êà∑
    const adminUserId = await createAdmin(supabase);
    
    // ÂàùÂßãÂåñÊ†áÁ≠æ
    const tagsData = await initializeTags(supabase);
    
    // ÂàùÂßãÂåñÊñáÁ´†
    const postsData = await initializePosts(supabase, adminUserId, tagsData);
    
    console.log('\nüéâ Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂÆåÊàêÔºÅ');
    console.log('\nüìã ÂàùÂßãÂåñÊëòË¶Å:');
    console.log(`üë§ ÁÆ°ÁêÜÂëòË¥¶Êà∑: Â∑≤ÂàõÂª∫`);
    console.log(`üè∑Ô∏è  Ê†áÁ≠æÊï∞Èáè: ${tagsData?.length}`);
    console.log(`üìù ÊñáÁ´†Êï∞Èáè: ${postsData?.length}`);
    
    console.log('\nüìñ Á§∫‰æãÊñáÁ´†:');
    postsData?.forEach((post: any, index: number) => {
      console.log(`   ${index + 1}. ${post.title}`);
      console.log(`      üìé slug: ${post.slug}`);
      console.log(`      üîó URL: /posts/${post.slug}\n`);
    });
    
    console.log('üí° ÊèêÁ§∫: ËøêË°å "npm run dev" ÂêØÂä®ÂºÄÂèëÊúçÂä°Âô®');
    console.log('üîë ‰ΩøÁî®ÂàöÊâçÂàõÂª∫ÁöÑÁÆ°ÁêÜÂëòË¥¶Êà∑ÁôªÂΩï /admin ÁÆ°ÁêÜÂêéÂè∞');
    
  } catch (error: any) {
    console.error('\n‚ùå ÂàùÂßãÂåñÂ§±Ë¥•:', error.message);
    console.log('\nüîß ÊïÖÈöúÊéíÈô§Ê≠•È™§:');
    console.log('1. Á°Æ‰øùÂ∑≤ÂàõÂª∫ .env.local Êñá‰ª∂');
    console.log('2. Á°Æ‰øùÂ∑≤ËÆæÁΩÆ NEXT_PUBLIC_SUPABASE_URL');
    console.log('3. Á°Æ‰øùÂ∑≤ËÆæÁΩÆ SUPABASE_SERVICE_ROLE_KEY');
    console.log('4. Ê£ÄÊü• Supabase È°πÁõÆÊòØÂê¶Ê≠£Â∏∏ËøêË°å');
    console.log('5. Á°Æ‰øùÂú® Supabase ‰∏≠Â∑≤ÂàõÂª∫ÊâÄÊúâÂøÖË¶ÅÁöÑË°®');
    
    console.log('\nüìã ÂΩìÂâçÁéØÂ¢ÉÂèòÈáèÁä∂ÊÄÅ:');
    console.log(`NEXT_PUBLIC_SUPABASE_URL: ${process.env.NEXT_PUBLIC_SUPABASE_URL ? 'Â∑≤ËÆæÁΩÆ' : 'Êú™ËÆæÁΩÆ'}`);
    console.log(`SUPABASE_SERVICE_ROLE_KEY: ${process.env.SUPABASE_SERVICE_ROLE_KEY ? 'Â∑≤ËÆæÁΩÆ' : 'Êú™ËÆæÁΩÆ'}`);
    
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY) {
      console.log('\nüìÑ ËØ∑Ê£ÄÊü• .env.local Êñá‰ª∂ÂÜÖÂÆπ:');
      console.log('NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co');
      console.log('SUPABASE_SERVICE_ROLE_KEY=your-service-role-key');
    }
    
    process.exit(1);
  } finally {
    rl.close();
  }
}

// Áõ¥Êé•ËøêË°åËÑöÊú¨
if (require.main === module) {
  initializeDatabase();
}

export { initializeDatabase, initialPosts, initialTags }; 